
# chess engine in relational math.

\l rel.k

## FEN chess notation display.

 There are 6 kind of pieces: King,Queen, Bishop,kNight,Rook,Pawn.
 The Forsyth-Edwards Notation use lower case letter for black pieces, and upper case for white pieces.
 There are 64 poistions in a chessboard.
 Positions are listed from 0(a8) to 63(h1) as FEN, as it's very natural to display it on a monitor.
 So instead of use chess ranks and files, we use row and column.

~~~
map: (raze string 1+til 8)!(1+til 8)#\:" "         ; / number 1 to 8 represent spaces.
map["/"]: "\n"                                     ; / / to separate each row.
unicode:"rnbqkpRNBQKP\n "! ("♜";"♞";"♝";"♛";"♚";"♟";"♖";"♘";"♗";"♕";"♔";"♙";"\n"; " ");
map[key unicode]:key unicode;

board:{ "\n"vs raze map x}                         ; /given a FEN, return the board as 8X8 byte arrays of pieces
bg: {"\033[48;5;106m",x,"\033[m"}                  ; /show x with different background color with ansi color.
showRow:{[b;r]: raze(::;bg)[r+til[8]mod 2]@'b[r]}  ; /show a row of chessboard
clr:(enlist"\033[2J")                              ; /clear screen
showFen:{clr,showRow[unicode@/:board x]each til 8} ; /show board with unicode and color
saveFen:{`:fen.txt 0: showFen x}                   ; / save board to a txt file, and cat in another terminal.
sh:{}                                              ; / show functions are empty in normal code
Show:{}

~~~

~~~
sh: {show 8 cut x;}       / But show x as 8 rows when generating Markdown.
Show: show;               /
fen:"5b2/p3n2r/3R2pp/k1p1Bp2/2B1p3/1P6/P1P2PPP/2K5"
;-1@raze map fen;         / Chess displayed in ascii,
     b  
p   n  r
   R  pp
k p Bp  
  B p   
 P      
P P  PPP
  K     
;-1@raze unicode map fen; /   and in unicode.
     ♝  
♟   ♞  ♜
   ♖  ♟♟
♚ ♟ ♗♟  
  ♗ ♟   
 ♙      
♙ ♙  ♙♙♙
  ♔     
saveFen fen               /and you can cat fen.txt in a terminal to see the colors.
`:fen.txt

~~~

## Chess Pieces attack positions.

 Each position have at most 1 pieces on it, so it's a partial function.
 Each live pieces have exactly 1 position, so it's a mapping(full function).

### Rook and Queen move and attacks in row and column.


~~~
sh Pos2Row: raze 8#'enlist each(neg til 8)rotate\:10000000b; / The relation from position to row
10000000b 10000000b 10000000b 10000000b 10000000b 10000000b 10000000b 10000000b
01000000b 01000000b 01000000b 01000000b 01000000b 01000000b 01000000b 01000000b
00100000b 00100000b 00100000b 00100000b 00100000b 00100000b 00100000b 00100000b
00010000b 00010000b 00010000b 00010000b 00010000b 00010000b 00010000b 00010000b
00001000b 00001000b 00001000b 00001000b 00001000b 00001000b 00001000b 00001000b
00000100b 00000100b 00000100b 00000100b 00000100b 00000100b 00000100b 00000100b
00000010b 00000010b 00000010b 00000010b 00000010b 00000010b 00000010b 00000010b
00000001b 00000001b 00000001b 00000001b 00000001b 00000001b 00000001b 00000001b
sh Pos2Col: raze 8# enlist     (neg til 8)rotate\:10000000b; /   and to column.
10000000b 01000000b 00100000b 00010000b 00001000b 00000100b 00000010b 00000001b
10000000b 01000000b 00100000b 00010000b 00001000b 00000100b 00000010b 00000001b
10000000b 01000000b 00100000b 00010000b 00001000b 00000100b 00000010b 00000001b
10000000b 01000000b 00100000b 00010000b 00001000b 00000100b 00000010b 00000001b
10000000b 01000000b 00100000b 00010000b 00001000b 00000100b 00000010b 00000001b
10000000b 01000000b 00100000b 00010000b 00001000b 00000100b 00000010b 00000001b
10000000b 01000000b 00100000b 00010000b 00001000b 00000100b 00000010b 00000001b
10000000b 01000000b 00100000b 00010000b 00001000b 00000100b 00000010b 00000001b
sh SameRow: same Pos2Row                                   ; / Positions of the same row
1111111100000000000000000000000000000000000000000000000000000000b 11111111000..
0000000011111111000000000000000000000000000000000000000000000000b 00000000111..
0000000000000000111111110000000000000000000000000000000000000000b 00000000000..
0000000000000000000000001111111100000000000000000000000000000000b 00000000000..
0000000000000000000000000000000011111111000000000000000000000000b 00000000000..
0000000000000000000000000000000000000000111111110000000000000000b 00000000000..
0000000000000000000000000000000000000000000000001111111100000000b 00000000000..
0000000000000000000000000000000000000000000000000000000011111111b 00000000000..
sh SameCol:same Pos2Col                                   ; /   and same rank.
1000000010000000100000001000000010000000100000001000000010000000b 01000000010..
1000000010000000100000001000000010000000100000001000000010000000b 01000000010..
1000000010000000100000001000000010000000100000001000000010000000b 01000000010..
1000000010000000100000001000000010000000100000001000000010000000b 01000000010..
1000000010000000100000001000000010000000100000001000000010000000b 01000000010..
1000000010000000100000001000000010000000100000001000000010000000b 01000000010..
1000000010000000100000001000000010000000100000001000000010000000b 01000000010..
1000000010000000100000001000000010000000100000001000000010000000b 01000000010..

~~~

### Bishop and Queen move and attack in diagonals
  There are each 15 diagonals at goes down and up( read from left to right), we use -7 .. 7 to represent each. 
  a8 is at up diagonal 7, a7->b8 6


~~~
diagonal: -7+til 15                                     ;
sh pos2Up: raze (-). (first where)@''(Pos2Col;Pos2Row)  ;
0  1  2  3  4  5  6  7
-1 0  1  2  3  4  5  6
-2 -1 0  1  2  3  4  5
-3 -2 -1 0  1  2  3  4
-4 -3 -2 -1 0  1  2  3
-5 -4 -3 -2 -1 0  1  2
-6 -5 -4 -3 -2 -1 0  1
-7 -6 -5 -4 -3 -2 -1 0
sh pos2Down: raze flip  8 cut pos2Up                    ;
0 -1 -2 -3 -4 -5 -6 -7
1 0  -1 -2 -3 -4 -5 -6
2 1  0  -1 -2 -3 -4 -5
3 2  1  0  -1 -2 -3 -4
4 3  2  1  0  -1 -2 -3
5 4  3  2  1  0  -1 -2
6 5  4  3  2  1  0  -1
7 6  5  4  3  2  1  0 
sh Pos2Up:   pos2Up  =\:diagonal                        ;
000000010000000b 000000001000000b 000000000100000b 000000000010000b 000000000..
000000100000000b 000000010000000b 000000001000000b 000000000100000b 000000000..
000001000000000b 000000100000000b 000000010000000b 000000001000000b 000000000..
000010000000000b 000001000000000b 000000100000000b 000000010000000b 000000001..
000100000000000b 000010000000000b 000001000000000b 000000100000000b 000000010..
001000000000000b 000100000000000b 000010000000000b 000001000000000b 000000100..
010000000000000b 001000000000000b 000100000000000b 000010000000000b 000001000..
100000000000000b 010000000000000b 001000000000000b 000100000000000b 000010000..
sh Pos2Down: pos2Down=\:diagonal                        ;
000000010000000b 000000100000000b 000001000000000b 000010000000000b 000100000..
000000001000000b 000000010000000b 000000100000000b 000001000000000b 000010000..
000000000100000b 000000001000000b 000000010000000b 000000100000000b 000001000..
000000000010000b 000000000100000b 000000001000000b 000000010000000b 000000100..
000000000001000b 000000000010000b 000000000100000b 000000001000000b 000000010..
000000000000100b 000000000001000b 000000000010000b 000000000100000b 000000001..
000000000000010b 000000000000100b 000000000001000b 000000000010000b 000000000..
000000000000001b 000000000000010b 000000000000100b 000000000001000b 000000000..
sh SameUp:  same Pos2Up                                 ;
1000000001000000001000000001000000001000000001000000001000000001b 01000000001..
0000000010000000010000000010000000010000000010000000010000000010b 10000000010..
0000000000000000100000000100000000100000000100000000100000000100b 00000000100..
0000000000000000000000001000000001000000001000000001000000001000b 00000000000..
0000000000000000000000000000000010000000010000000010000000010000b 00000000000..
0000000000000000000000000000000000000000100000000100000000100000b 00000000000..
0000000000000000000000000000000000000000000000001000000001000000b 00000000000..
0000000000000000000000000000000000000000000000000000000010000000b 00000000000..
sh SameDown:same Pos2Down                               ;
1000000001000000001000000001000000001000000001000000001000000001b 01000000001..
0000000010000000010000000010000000010000000010000000010000000010b 10000000010..
0000000000000000100000000100000000100000000100000000100000000100b 00000000100..
0000000000000000000000001000000001000000001000000001000000001000b 00000000000..
0000000000000000000000000000000010000000010000000010000000010000b 00000000000..
0000000000000000000000000000000000000000100000000100000000100000b 00000000000..
0000000000000000000000000000000000000000000000001000000001000000b 00000000000..
0000000000000000000000000000000000000000000000000000000010000000b 00000000000..

~~~

### King move/attack in 1 step.

 King can move/attack 1 step in any direction, except those are occupied by it's own piece, or attacked by the opposite.

~~~
sh                 raze (first where)@'Pos2Row  /convert boolean array to row
0 0 0 0 0 0 0 0
1 1 1 1 1 1 1 1
2 2 2 2 2 2 2 2
3 3 3 3 3 3 3 3
4 4 4 4 4 4 4 4
5 5 5 5 5 5 5 5
6 6 6 6 6 6 6 6
7 7 7 7 7 7 7 7
sh {2>abs x-/:\:x} raze (first where)@'Pos2Row  /positions with row difference <2
1111111111111111000000000000000000000000000000000000000000000000b 11111111111..
1111111111111111111111110000000000000000000000000000000000000000b 11111111111..
0000000011111111111111111111111100000000000000000000000000000000b 00000000111..
0000000000000000111111111111111111111111000000000000000000000000b 00000000000..
0000000000000000000000001111111111111111111111110000000000000000b 00000000000..
0000000000000000000000000000000011111111111111111111111100000000b 00000000000..
0000000000000000000000000000000000000000111111111111111111111111b 00000000000..
0000000000000000000000000000000000000000000000001111111111111111b 00000000000..

~~~


~~~
Show king: (and). {2>abs x-/:\:x} each raze each (first where)@''(Pos2Row;Pos2Col);
1100000011000000000000000000000000000000000000000000000000000000b
1110000011100000000000000000000000000000000000000000000000000000b
0111000001110000000000000000000000000000000000000000000000000000b
0011100000111000000000000000000000000000000000000000000000000000b
0001110000011100000000000000000000000000000000000000000000000000b
0000111000001110000000000000000000000000000000000000000000000000b
0000011100000111000000000000000000000000000000000000000000000000b
0000001100000011000000000000000000000000000000000000000000000000b
1100000011000000110000000000000000000000000000000000000000000000b
1110000011100000111000000000000000000000000000000000000000000000b
0111000001110000011100000000000000000000000000000000000000000000b
0011100000111000001110000000000000000000000000000000000000000000b
0001110000011100000111000000000000000000000000000000000000000000b
0000111000001110000011100000000000000000000000000000000000000000b
0000011100000111000001110000000000000000000000000000000000000000b
0000001100000011000000110000000000000000000000000000000000000000b
0000000011000000110000001100000000000000000000000000000000000000b
0000000011100000111000001110000000000000000000000000000000000000b
0000000001110000011100000111000000000000000000000000000000000000b
0000000000111000001110000011100000000000000000000000000000000000b
0000000000011100000111000001110000000000000000000000000000000000b
0000000000001110000011100000111000000000000000000000000000000000b
..

~~~


~~~
/ Given above board,
/ Here is where the king can move to.
bd: board fen
sh k: king (raze bd)?"k"
00000000b
00000000b
11000000b
11000000b
11000000b
00000000b
00000000b
00000000b
/ White rook Rd6 attacks rank 6, and file d. We ignore block here first.
sh k&: not SameCol raze[bd] ? "R"
00000000b
00000000b
11000000b
11000000b
11000000b
00000000b
00000000b
00000000b
sh k&: not SameRow raze[bd] ? "R"
00000000b
00000000b
00000000b
11000000b
11000000b
00000000b
00000000b
00000000b

~~~

#### Pawn attack: white pawn(P) attack up left and up right, so row+1, rank+-1

/ instead of convert position 10000000b to number and +-1, we can shift
/ shift y to the right x digits, with 0 padding

~~~
rshift:{ (x#0b),neg[x] _ y}
lshift:{ (x _ y),x#0b}

~~~

~~~
rshift[1; 1000b]
0100b
lshift[1; 0100b]
1000b

~~~

## Goal: use relational math to represent a chess board, and solve a simple puzzle (mobility analysis).



